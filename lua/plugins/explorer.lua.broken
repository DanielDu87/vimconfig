--==============================================================================
-- Snacks Explorer 剪切/复制/粘贴功能
--==============================================================================
-- 使用内部剪贴板实现文件操作

return {
	{
		"folke/snacks.nvim",
		opts = function(_, opts)
			opts.picker = opts.picker or {}
			opts.picker.explorer = opts.picker.explorer or {}

			--======================================================================
			-- 内部剪贴板
			--======================================================================
			local clipboard = {
				mode = nil, -- "cut" | "copy"
				items = {}, -- { path1, path2, ... }
			}

			--======================================================================
			-- 添加键位映射
			--======================================================================
			opts.picker.explorer.keys = opts.picker.explorer.keys or {}

			-- 剪切（x）
			opts.picker.explorer.keys["x"] = function(picker)
				local files = {} ---@type string[]
				if vim.fn.mode():find("^[vV]") then
					picker.list:select()
				end
				for _, item in ipairs(picker:selected({ fallback = true })) do
					table.insert(files, Snacks.picker.util.path(item))
				end
				picker.list:set_selected()

				clipboard.mode = "cut"
				clipboard.items = files
				local file_list = table.concat(files, "\n- ")
				Snacks.notify.info("已剪切 " .. #files .. " 个文件：\n- " .. file_list)
			end

			-- 复制到剪贴板（c，不覆盖原有的复制功能）
			opts.picker.explorer.keys["<c-c>"] = function(picker)
				local files = {} ---@type string[]
				if vim.fn.mode():find("^[vV]") then
					picker.list:select()
				end
				for _, item in ipairs(picker:selected({ fallback = true })) do
					table.insert(files, Snacks.picker.util.path(item))
				end
				picker.list:set_selected()

				clipboard.mode = "copy"
				clipboard.items = files
				local file_list = table.concat(files, "\n- ")
				Snacks.notify.info("已复制 " .. #files .. " 个文件到剪贴板：\n- " .. file_list)
			end

			-- 粘贴（p）
			opts.picker.explorer.keys["p"] = function(picker)
				if not clipboard.mode or #clipboard.items == 0 then
					Snacks.notify.warn("剪贴板为空")
					return
				end

				local target_dir = picker:dir()
				local Actions = require("snacks.explorer.actions")
				local file_list = table.concat(clipboard.items, "\n- ")

				if clipboard.mode == "cut" then
					-- 剪切模式：移动文件
					for _, from in ipairs(clipboard.items) do
						local to = target_dir .. "/" .. vim.fn.fnamemodify(from, ":t")
						to = vim.fs.normalize(to)

						-- 检查目标是否已存在
						if vim.uv.fs_stat(to) then
							Snacks.notify.warn("目标已存在：\n- " .. to)
						else
							local ok, err = pcall(Snacks.rename.rename_file, { from = from, to = to })
							if not ok then
								Snacks.notify.error("移动失败 `" .. from .. "`：\n" .. (err or "未知错误"))
							else
								local Tree = require("snacks.explorer.tree")
								Tree:refresh(vim.fs.dirname(from))
							end
						end
					end

					-- 清空剪贴板
					clipboard.mode = nil
					clipboard.items = {}

					local Tree = require("snacks.explorer.tree")
					Tree:refresh(target_dir)
					Actions.update(picker, { target = target_dir })
					Snacks.notify.info("已移动 " .. #clipboard.items .. " 个文件到：\n- " .. target_dir)
				else
					-- 复制模式：复制文件
					for _, from in ipairs(clipboard.items) do
						local to = target_dir .. "/" .. vim.fn.fnamemodify(from, ":t")
						to = vim.fs.normalize(to)

						-- 检查目标是否已存在
						if vim.uv.fs_stat(to) then
							Snacks.notify.warn("目标已存在：\n- " .. to)
						else
							local ok, err = pcall(Snacks.picker.util.copy_path, from, to)
							if not ok then
								Snacks.notify.error("复制失败 `" .. from .. "`：\n" .. (err or "未知错误"))
							end
						end
					end

					local Tree = require("snacks.explorer.tree")
					Tree:refresh(target_dir)
					Actions.update(picker, { target = target_dir })
					Snacks.notify.info("已粘贴 " .. #clipboard.items .. " 个文件到：\n- " .. target_dir)
				end
			end

			-- 清空剪贴板（可选）
			opts.picker.explorer.keys["<X>"] = function()
				clipboard.mode = nil
				clipboard.items = {}
				Snacks.notify.info("已清空剪贴板")
			end

			--======================================================================
			-- 处理目录参数启动
			--======================================================================
			local start_with_dir = false
			for _, a in ipairs(vim.fn.argv()) do
				if not vim.startswith(a, "-") and vim.fn.isdirectory(a) == 1 then
					start_with_dir = true
					vim.cmd("cd " .. vim.fn.fnamemodify(a, ":p"))
					break
				end
			end

			--======================================================================
			-- 启动时自动打开 Explorer（仅当非目录参数启动时）
			--======================================================================
			if not start_with_dir then
				vim.api.nvim_create_autocmd("VimEnter", {
					group = vim.api.nvim_create_augroup("SnacksExplorerAutoStart", { clear = true }),
					once = true,
					callback = function()
						vim.schedule(function()
							local ok, Snacks = pcall(require, "snacks")
							if not ok or not Snacks.explorer then
								return
							end

							-- 检查是否已经有 Explorer 窗口
							local has_explorer = false
							for _, win in ipairs(vim.api.nvim_list_wins()) do
								local buf = vim.api.nvim_win_get_buf(win)
								local buf_name = vim.api.nvim_buf_get_name(buf)
								if buf_name:match("[Ee]xplorer") or buf_name:match("[Ss]nacks") or buf_name:match("picker") then
									has_explorer = true
									break
								end
							end

							if not has_explorer then
								local root = vim.g.root_dir
									or (_G.LazyVim and _G.LazyVim.root and _G.LazyVim.root.get and _G.LazyVim.root.get())
									or vim.fn.getcwd()
								Snacks.explorer.open({ cwd = root })

								-- 如果打开了文件，焦点回到文件窗口
								local argv = vim.fn.argv()
								local has_file = false
								for _, a in ipairs(argv) do
									if not vim.startswith(a, "-") and vim.fn.isdirectory(a) == 0 then
										has_file = true
										break
									end
								end

								if has_file then
									vim.schedule(function()
										vim.cmd("wincmd p")
									end)
								end
							end
						end)
					end,
					desc = "启动时自动打开 Snacks Explorer",
				})
			end
		end,
	},
}

--==============================================================================
-- 中文化其他 Explorer Actions
--==============================================================================
vim.api.nvim_create_autocmd("VimEnter", {
	once = true,
	callback = function()
		local Actions = require("snacks.explorer.actions")
		local uv = vim.uv or vim.loop

		-- 复制到系统寄存器（y）
		Actions.actions.explorer_yank = function(picker)
			local files = {} ---@type string[]
			if vim.fn.mode():find("^[vV]") then
				picker.list:select()
			end
			for _, item in ipairs(picker:selected({ fallback = true })) do
				table.insert(files, Snacks.picker.util.path(item))
			end
			picker.list:set_selected()
			local value = table.concat(files, "\n")
			vim.fn.setreg(vim.v.register or "+", value, "l")
			local file_list = table.concat(files, "\n- ")
			Snacks.notify.info("已复制 " .. #files .. " 个文件到系统寄存器：\n- " .. file_list)
		end

		-- 粘贴（从系统寄存器）
		Actions.actions.explorer_paste = function(picker)
			local files = vim.split(vim.fn.getreg(vim.v.register or "+") or "", "\n", { plain = true })
			files = vim.tbl_filter(function(file)
				return file ~= "" and vim.fn.filereadable(file) == 1
			end, files)

			if #files == 0 then
				return Snacks.notify.warn("系统寄存器中没有文件")
			end

			local dir = picker:dir()
			Snacks.picker.util.copy(files, dir)
			local Tree = require("snacks.explorer.tree")
			Tree:refresh(dir)
			Tree:open(dir)
			Actions.update(picker, { target = dir })
			local file_list = table.concat(files, "\n- ")
			Snacks.notify.info("已粘贴 " .. #files .. " 个文件：\n- " .. file_list)
		end

		-- 新建文件/目录
		Actions.actions.explorer_add = function(picker)
			Snacks.input({
				prompt = "新建文件或目录（目录以 / 结尾）：",
			}, function(value)
				if not value or value:find("^%s$") then
					return
				end
				local path = vim.fs.normalize(picker:dir() .. "/" .. value)
				local is_file = value:sub(-1) ~= "/"
				local dir = is_file and vim.fs.dirname(path) or path
				if is_file and uv.fs_stat(path) then
					Snacks.notify.warn("文件已存在：\n- " .. path)
					return
				end
				local ok, err = pcall(vim.fn.mkdir, dir, "p")
				if not ok then
					Snacks.notify.error("创建目录失败：\n- " .. (err or "未知错误"))
					return
				end
				if is_file then
					local f, open_err = io.open(path, "w")
					if not f then
						Snacks.notify.error("创建文件失败：\n- " .. (open_err or "未知错误"))
						return
					end
					f:close()
				end
				local Tree = require("snacks.explorer.tree")
				Tree:open(dir)
				Tree:refresh(dir)
				Actions.update(picker, { target = path })
				local msg_type = is_file and "文件" or "目录"
				Snacks.notify.info("已创建" .. msg_type .. "：\n- " .. path)
			end)
		end

		-- 重命名文件
		Actions.actions.explorer_rename = function(picker, item)
			if not item then
				return Snacks.notify.warn("未选择文件")
			end

			local old_name = vim.fn.fnamemodify(item.file, ":t")

			Snacks.input({
				prompt = "重命名：",
				default = old_name,
			}, function(new_name)
				if not new_name or new_name == "" or new_name == old_name then
					return
				end
				local new_path = vim.fs.normalize(vim.fs.dirname(item.file) .. "/" .. new_name)

				if uv.fs_stat(new_path) then
					Snacks.notify.warn("目标文件已存在：\n- " .. new_path)
					return
				end

				Snacks.rename.rename_file({
					from = item.file,
					to = new_path,
					on_rename = function(new, old)
						local Tree = require("snacks.explorer.tree")
						Tree:refresh(vim.fs.dirname(old))
						Tree:refresh(vim.fs.dirname(new))
						Actions.update(picker, { target = new })
						Snacks.notify.info("已重命名为：\n- " .. new)
					end,
				})
			end)
		end

		-- 复制文件
		Actions.actions.explorer_copy = function(picker, item)
			if not item then
				return Snacks.notify.warn("未选择文件")
			end
			local paths = vim.tbl_map(Snacks.picker.util.path, picker:selected())
			if #paths > 0 then
				local dir = picker:dir()
				local file_list = table.concat(paths, "\n- ")
				Snacks.picker.util.copy(paths, dir)
				picker.list:set_selected()
				local Tree = require("snacks.explorer.tree")
				Tree:refresh(dir)
				Tree:open(dir)
				Actions.update(picker, { target = dir })
				Snacks.notify.info("已复制 " .. #paths .. " 个文件：\n- " .. file_list)
				return
			end
			Snacks.input({
				prompt = "复制到：",
				default = vim.fn.fnamemodify(item.file, ":t"),
			}, function(value)
				if not value or value:find("^%s$") then
					return
				end
				local dir = vim.fs.dirname(item.file)
				local to = vim.fs.normalize(dir .. "/" .. value)
				if uv.fs_stat(to) then
					Snacks.notify.warn("目标文件已存在：\n- " .. to)
					return
				end
				local ok, err = pcall(Snacks.picker.util.copy_path, item.file, to)
				if not ok then
					Snacks.notify.error("复制文件失败：\n- `" .. item.file .. "`\n- " .. (err or "未知错误"))
					return
				end
				local Tree = require("snacks.explorer.tree")
				Tree:refresh(vim.fs.dirname(to))
				Actions.update(picker, { target = to })
				Snacks.notify.info("已复制文件到：\n- " .. to)
			end)
		end

		-- 移动文件
		Actions.actions.explorer_move = function(picker)
			local paths = vim.tbl_map(Snacks.picker.util.path, picker:selected())
			if #paths == 0 then
				local current = picker:current()
				if current then
					paths = { Snacks.picker.util.path(current) }
				else
					return Snacks.notify.warn("未选择文件")
				end
			end

			if #paths == 1 then
				local from = paths[1]
				Snacks.input({
					prompt = "移动到：",
					default = from,
				}, function(value)
					if not value or value == "" or value == from then
						return
					end
					local to = vim.fs.normalize(value)
					if uv.fs_stat(to) then
						Snacks.notify.warn("目标文件已存在：\n- " .. to)
						return
					end
					local ok, err = pcall(Snacks.rename.rename_file, { from = from, to = to })
					if not ok then
						Snacks.notify.error("移动失败 `" .. from .. "`：\n" .. (err or "未知错误"))
						return
					end
					local Tree = require("snacks.explorer.tree")
					Tree:refresh(vim.fs.dirname(from))
					Tree:refresh(vim.fs.dirname(to))
					picker.list:set_selected()
					Actions.update(picker, { target = to })
					Snacks.notify.info("已移动文件：\n- `" .. from .. "`\n到：\n- `" .. to .. "`")
				end)
				return
			end

			local target = picker:dir()
			local file_list = table.concat(paths, "\n- ")
			for _, from in ipairs(paths) do
				local to = target .. "/" .. vim.fn.fnamemodify(from, ":t")
				local ok, err = pcall(Snacks.rename.rename_file, { from = from, to = to })
				if not ok then
					Snacks.notify.error("移动失败 `" .. from .. "`：\n" .. (err or "未知错误"))
				end
				local Tree = require("snacks.explorer.tree")
				Tree:refresh(vim.fs.dirname(from))
			end
			local Tree = require("snacks.explorer.tree")
			Tree:refresh(target)
			picker.list:set_selected()
			Actions.update(picker, { target = target })
			Snacks.notify.info("已移动 " .. #paths .. " 个文件到：\n- `" .. target .. "`\n文件：\n- " .. file_list)
		end

		-- 删除文件
		Actions.actions.explorer_del = function(picker)
			local paths = vim.tbl_map(Snacks.picker.util.path, picker:selected({ fallback = true }))
			if #paths == 0 then
				return Snacks.notify.warn("未选择文件")
			end
			local filenames = vim.tbl_map(function(p)
				local name = vim.fn.fnamemodify(p, ":t")
				return name:gsub("@$", "")
			end, paths)
			local msg
			if #paths == 1 then
				msg = "是否删除 " .. filenames[1] .. "？"
			else
				local filename_list = table.concat(filenames, "\n- ")
				msg = "是否删除 " .. #paths .. " 个文件？\n- " .. filename_list
			end
			Snacks.picker.util.confirm(msg, function()
				for _, path in ipairs(paths) do
					local ok, err = Actions.trash(path)
					if ok then
						Snacks.bufdelete({ file = path, force = true })
					else
						Snacks.notify.error("删除失败 `" .. path .. "`：\n" .. err)
					end
					local Tree = require("snacks.explorer.tree")
					Tree:refresh(vim.fs.dirname(path))
				end
				picker.list:set_selected()
				Actions.update(picker)
				local file_list = table.concat(paths, "\n- ")
				Snacks.notify.info("已删除 " .. #paths .. " 个文件：\n- " .. file_list)
			end)
		end

		-- 打开文件
		Actions.actions.explorer_open = function(_, item)
			if item then
				local _, err = vim.ui.open(item.file)
				if err then
					Snacks.notify.error("打开文件失败 `" .. item.file .. "`：\n- " .. err)
				end
			end
		end
	end,
})
